# LB 25689

Лаба №2
Реализовал следующую иерархию:
  Product:
    Есть абстрактный класс Product:
      В нём поля name, weight, геттеры и сеттеры, 
      а также метод абстрактный метод getDetails, который будет переопределён в дочерних классах
    Класс Box наследуется от класса Product:
      Определено поле contents, сттер и геттер,
      А также переопределён метод getDetails класса Product
    Класс Boxes:
      содержит поле boxesList, которое хранит в себе Боксы в виде списка
  Transport:
    Интерфейс Transportable, содержащий в себе 2 метода: deliver и setDeliverableProducts
    Абстрактный класс Transport реализующий интерфейс Transportable и содерж. поле currentProducts 
    Класс Ship и Truck со своими реализациями deliver и setDeliverableProducts
  Warehouse:
    Класс Warehouse, содержащий в себе поле products и 2 метода getDeliver и showProducts

Лаба№5(парсинг XML)
  Для этого я использовал JAXB парсер.
  В Boxes.xml содержатся данные об сущестующих боксах
    1)Для начала определяем классы для сопоставления данных XML с объектами в Java^
      Помечаем класс Boxes как корневой элемент @XmlRootElement(name = "boxes")
      и его поля будут использоваться как вложенные данные в xml @XmlAccessorType(XmlAccessType.FIELD)
      Помечаем поле boxesList, как вложенные данные box (т.к у нас несколько боксов, они будут считываться в список)
      сеттер и геттер
      Мы сейчас определили как будет парситься тег boxes 
      Так же нам надо определить как будут парситься сами боксы
      Так же помечаем класс Box как корневой элемент и 
      что его поля будут использоваться для представления его вложенной информации в xml файле
      Т.к поле contents будет содержать много данных, то пометим что внутри его будет ещё много данных:
         @XmlElementWrapper(name = "contents")
         @XmlElement(name = "content")
    2)В классе Main в главном методеЖ
        1.создаём JAXBcontext, который определяет какие классы будут использоваться для маршализации
        2.создаём от него Unmarshaller, чтобы считывать даннные
        3.Анмаршаллим файл методом unmarshal и получаем в результате объект boxes, состоящий из данных xml файла
  Чтобы показать как точно прочлись файлы, я вывел их в консоль через доставку груза транспортом в склад,
  который сообщает какой товар прибыл

Лаба№6(паттерны)
  Я реализовал 2 паттерна: порождающий Фабрика и поведенческий Стратегия:
    --------------------------------------------------------------------
    Фабрика позволяет нам создавать разные типы данных, 
    относящиеся к одному типу через один и тот же метод соответствующих фабрик(классов, которые создают новый объект соотв. класса), которые используют фабрику создания этого одного типа данных
    В моём случае, Box относится к типу постовляемый продукт(Product), 
    чтобы создавать разные продукты определим интерфейс ProductFactory,
    где метод createProduct должен будет реализовывать создание продукта, который будут реализовывать все фабрики,
    которые в свою очередь будут создавать соответствующий продукт
    Далее определяем BoxFactory, который создает методом createProduct уже не продукт, а конкретно Box
    Так можно определить множество фабрик под соответствующие подтипы продуктов, при этом вызывая всё тот же метод createProduct
    --------------------------------------------------------------------------------------------
    Стратегия позволяет для каждого подтипа, установить своё поведение одного и того же действия.
    В моём случае, эти поведения определены в интерфейсе Transportable: deliver и setDeliverableProducts
    Затем этот интерфейс реализует абстрактный класс Transport
    После чего создаём классы Ship и Truck, который в свою очередь имеют свою реализацию deliver и setDeliverableProducts
    Таким образом если нам нужно доставить на склад продукты, либо же погрузить их на транспорт, у каждого типа транспорта будет свой способ реализации этих действий

Лаба8(плагины мавен)
  в pom.xml я добавил 3 плагина:
    1) Создаёт jar файл проекта
    2) Копирует зависимости в папку target
    3) Сообщает об версии подключённых зависимостей
    Подключаются плагины через тег plugin в теге plugins, который в свою очередь находится в теге build
    Плагины нужны для доп. действий над проектом, создание отчётов, сбор различной информации, автоматизация каких либо действий

Лаба№9
